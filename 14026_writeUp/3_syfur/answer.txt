When I executed the binary with gdb, I realized that the function <not_flag()> was needed to be called for displaying the flag. The function <find_flag()> was being called from inside <main()>. One of the way to call the <not_flag()> function was to change the return address of the <not_flag()> function. I also saw that just before returning from <get_flag()> the input string was being stored in the form of < 0xd0000000 + hex(input) > at the memory location <0xffffdb4e>. Also, the return address of <get_flag()> was stored in the memory location <0xffffdbac>. So, if I was able to change the value stored in the memory address <0xffffdbac> to <0x804856f>, it would display the flag. So, if my input was 94(<0xffffdbac> - <0xffffdb4e> in decimal) random bytes followed by <0x804856f> in little endian format, flag would be displayed. Finally, I ran the following command which displayed the flag:

<echo `python -c 'print("A"*94+"\x6f\x85\x04\x08")'` | ./3_syfur>